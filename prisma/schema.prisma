generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
}

// =========================================================
// 1. ENUMS
// =========================================================

enum MediaType {
  ANIME
  MANGA
  NOVEL
}

enum MediaStatus {
  RELEASING
  FINISHED
  NOT_YET_RELEASED
  CANCELLED
}

enum LibraryStatus {
  WATCHING
  READING
  COMPLETED
  PLANNING
  DROPPED
  PAUSED
}

enum PrivacyMode {
  PUBLIC
  PRIVATE
  SHARED
}

enum ChannelType {
  TEXT
  VOICE
  WATCH_PARTY
}

enum UserRole {
  ADMIN
  MODERATOR
  MEMBER
}

enum RelationshipType {
  FOLLOW
  FRIEND
  BLOCK
}

enum ListPerm {
  EDITOR
  VIEWER
}

enum InviteStatus {
  PENDING
  ACCEPTED
  DECLINED
}

// =========================================================
// 2. USER & SOCIAL GRAPH
// =========================================================

model User {
  id            BigInt   @id @default(autoincrement())
  username      String   @unique
  email         String   @unique
  passwordHash  String
  avatar        String?
  statusMessage String?
  settings      Json? // { theme: "dark", notify: true }
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relationships
  libraryEntries LibraryEntry[]
  progressLogs   ProgressLog[] // Short-cut relation if needed

  // Lists
  ownedLists          CustomList[]
  listInvitesSent     ListInvitation[] @relation("Inviter")
  listInvitesReceived ListInvitation[] @relation("Invitee")
  addedListItems      ListItem[] // Items user added to shared lists

  // Social Graph
  followers UserRelationship[] @relation("UserFollowers")
  following UserRelationship[] @relation("UserFollowing")

  // Community & Chat
  ownedCommunities  Community[]
  joinedCommunities CommunityMember[]

  // DM & Channels
  channelParticipants ChannelParticipant[]
  messages            Message[]

  // Realtime & Activities
  hostedRooms WatchRoomConfig[]
  activities  Activity[]
  comments    Comment[]

  @@map("users")
}

model UserRelationship {
  followerId  BigInt
  followingId BigInt
  type        RelationshipType
  createdAt   DateTime         @default(now())

  follower  User @relation("UserFollowing", fields: [followerId], references: [id])
  following User @relation("UserFollowers", fields: [followingId], references: [id])

  @@id([followerId, followingId]) // Composite PK
  @@map("user_relationships")
}

// =========================================================
// 3. MEDIA MODULE (Inheritance)
// =========================================================

model MediaItem {
  id BigInt @id @default(autoincrement())

  // Sync IDs
  idAnilist    Int?      @unique
  idMal        Int?      @unique
  idMangadex   String?   @unique
  lastSyncedAt DateTime?

  // Metadata
  titleRomaji  String
  titleEnglish String?
  titleNative  String?
  type         MediaType
  status       MediaStatus
  coverImage   String?
  bannerImage  String?
  isAdult      Boolean     @default(false)
  averageScore Float?
  description  String?     @db.Text
  synonyms     Json?
  genres       Json?
  tags         Json?
  popularity   Int?
  favorites    Int?
  meanScore    Float?

  // Inheritance Extensions
  animeMetadata AnimeMetadata?
  bookMetadata  BookMetadata?

  // Relations
  libraryEntries LibraryEntry[]
  listItems      ListItem[]
  watchRooms     WatchRoomConfig[]
  activities     Activity[]

  @@map("media_items")
}

model AnimeMetadata {
  mediaId BigInt    @id // PK đồng thời là FK
  media   MediaItem @relation(fields: [mediaId], references: [id], onDelete: Cascade)

  episodeCount      Int?
  durationMin       Int?
  season            String? // "WINTER", "SUMMER"
  seasonYear        Int?
  studio            String?
  source            String?
  trailerUrl        String?
  nextAiringEpisode Json?

  @@map("anime_metadata")
}

model BookMetadata {
  mediaId BigInt    @id
  media   MediaItem @relation(fields: [mediaId], references: [id], onDelete: Cascade)

  chapters      Int?
  volumes       Int?
  author        Json? // [{name: "Oda", role: "Art"}]
  serialization String?

  @@map("book_metadata")
}

// =========================================================
// 4. LIBRARY & TRACKING
// =========================================================

model LibraryEntry {
  id              BigInt        @id @default(autoincrement())
  userId          BigInt
  mediaId         BigInt
  status          LibraryStatus
  progress        Int           @default(0) // Số tập/chap đã xem
  progressVolumes Int? // Cho Manga
  score           Float?
  notes           String?       @db.Text
  isPrivate       Boolean       @default(false)
  rewatchCount    Int           @default(0)
  startDate       DateTime?     @db.Date
  finishDate      DateTime?     @db.Date
  updatedAt       DateTime      @updatedAt

  user  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  media MediaItem @relation(fields: [mediaId], references: [id], onDelete: Cascade)

  progressLogs ProgressLog[]

  @@unique([userId, mediaId])
  @@map("library_entries")
}

model ProgressLog {
  id             BigInt   @id @default(autoincrement())
  entryId        BigInt
  userId         BigInt
  progressNumber Int
  createdAt      DateTime @default(now())

  entry LibraryEntry @relation(fields: [entryId], references: [id], onDelete: Cascade)
  user  User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("progress_logs")
}

// =========================================================
// 5. LISTS (Sharing)
// =========================================================

model CustomList {
  id          BigInt      @id @default(autoincrement())
  ownerId     BigInt
  name        String
  slug        String      @unique
  description String?     @db.Text
  privacy     PrivacyMode @default(PUBLIC)
  bannerImage String?
  settings    Json?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  owner       User             @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  items       ListItem[]
  invitations ListInvitation[]

  // Polymorphic Relations
  activities Activity[]

  @@map("custom_lists")
}

model ListItem {
  id         BigInt   @id @default(autoincrement())
  listId     BigInt
  mediaId    BigInt
  addedById  BigInt
  orderIndex Int      @default(0)
  note       String?  @db.Text
  createdAt  DateTime @default(now())

  list    CustomList @relation(fields: [listId], references: [id], onDelete: Cascade)
  media   MediaItem  @relation(fields: [mediaId], references: [id], onDelete: Cascade)
  addedBy User       @relation(fields: [addedById], references: [id])

  @@map("list_items")
}

model ListInvitation {
  id         BigInt       @id @default(autoincrement())
  listId     BigInt
  inviterId  BigInt
  inviteeId  BigInt
  permission ListPerm
  status     InviteStatus @default(PENDING)
  createdAt  DateTime     @default(now())

  list    CustomList @relation(fields: [listId], references: [id], onDelete: Cascade)
  inviter User       @relation("Inviter", fields: [inviterId], references: [id])
  invitee User       @relation("Invitee", fields: [inviteeId], references: [id])

  @@map("list_invitations")
}

// =========================================================
// 6. COMMUNITY & CHAT CORE
// =========================================================

model Community {
  id          BigInt   @id @default(autoincrement())
  ownerId     BigInt
  name        String
  icon        String?
  description String?  @db.Text
  isPublic    Boolean  @default(true)
  inviteCode  String?  @unique
  createdAt   DateTime @default(now())

  owner      User              @relation(fields: [ownerId], references: [id])
  members    CommunityMember[]
  channels   Channel[]
  activities Activity[]

  @@map("communities")
}

model CommunityMember {
  communityId BigInt
  userId      BigInt
  role        UserRole @default(MEMBER)
  nickname    String?
  joinedAt    DateTime @default(now())

  community Community @relation(fields: [communityId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([communityId, userId])
  @@map("community_members")
}

model Channel {
  id          BigInt      @id @default(autoincrement())
  communityId BigInt?
  name        String?
  type        ChannelType
  isPrivate   Boolean     @default(false)
  position    Int         @default(0)
  createdAt   DateTime    @default(now())

  community Community? @relation(fields: [communityId], references: [id], onDelete: Cascade)

  participants ChannelParticipant[]
  messages     Message[]

  watchRoomConfig WatchRoomConfig?

  @@map("channels")
}

model ChannelParticipant {
  channelId  BigInt
  userId     BigInt
  lastReadAt DateTime?
  isMuted    Boolean   @default(false)

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([channelId, userId])
  @@map("channel_participants")
}

model Message {
  id              BigInt   @id @default(autoincrement())
  channelId       BigInt
  senderId        BigInt
  replyToId       BigInt?
  content         String?  @db.Text
  attachments     Json?
  isSystemMessage Boolean  @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  channel Channel   @relation(fields: [channelId], references: [id], onDelete: Cascade)
  sender  User      @relation(fields: [senderId], references: [id])
  replyTo Message?  @relation("Thread", fields: [replyToId], references: [id])
  replies Message[] @relation("Thread")

  @@map("messages")
}

// =========================================================
// 7. INTEGRATION BRIDGES 
// =========================================================

// BRIDGE 1: Watch Party Config 
model WatchRoomConfig {
  channelId BigInt  @id
  channel   Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  mediaId BigInt?
  media   MediaItem? @relation(fields: [mediaId], references: [id])

  hostId BigInt?
  host   User?   @relation(fields: [hostId], references: [id])

  isPlaying        Boolean  @default(false)
  currentTimestamp Float    @default(0.0)
  currentSourceUrl String?
  playlistQueue    Json?
  settings         Json?
  lastSyncedAt     DateTime @default(now())

  @@map("watch_room_configs")
}

// BRIDGE 2: Activities & Comments (Polymorphic)

model Activity {
  id        BigInt   @id @default(autoincrement())
  userId    BigInt
  type      String // "WATCHED", "RATED", "JOINED", "CREATED_LIST"
  createdAt DateTime @default(now())
  metaData  Json?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  mediaId BigInt?
  media   MediaItem? @relation(fields: [mediaId], references: [id])

  listId BigInt?
  list   CustomList? @relation(fields: [listId], references: [id])

  communityId BigInt?
  community   Community? @relation(fields: [communityId], references: [id])

  comments Comment[]

  @@index([userId])
  @@map("activities")
}

model Comment {
  id        BigInt   @id @default(autoincrement())
  userId    BigInt
  content   String   @db.Text
  isSpoiler Boolean  @default(false)
  likeCount Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  mediaId BigInt?

  listId BigInt?

  activityId BigInt?
  activity   Activity? @relation(fields: [activityId], references: [id], onDelete: Cascade)

  targetType String? // "MEDIA", "LIST", "EPISODE"
  targetId   BigInt?

  @@map("comments")
}
